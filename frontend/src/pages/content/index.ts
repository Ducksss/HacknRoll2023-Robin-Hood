// @ts-nocheck
import _ from "lodash";

var threshold = 30;
var activePopup = false;
var audience = "Knowledgeable",
    formality = "Neutral",
    positivity = "Neutral",
    intent,
    context;

// Get the wrapper element
function getWrapper() {
    return document.querySelectorAll('div[class="notion-page-content"]')[0];
}

// Function to scan for new elements
let scanDiv = (function () {
    var MutationObserver =
        window.MutationObserver || window.WebKitMutationObserver;
    return function (obj, callback) {
        if (!obj || obj.nodeType !== 1) return;
        if (MutationObserver) {
            var mutationObserver = new MutationObserver(callback);
            mutationObserver.observe(obj, {
                childList: true,
                subtree: false
            });
            return mutationObserver;
        } else if (window.addEventListener) {
            obj.addEventListener("DOMNodeInserted", callback, false);
            obj.addEventListener("DOMNodeRemoved", callback, false);
        }
    };
})();

// Get the text content from the scanDiv wrapper
let getTextContent = (function () {
    return function (el) {
        el.querySelectorAll('div[class="notion-selectable"]');
        let block = el.querySelectorAll('div[class="notion-selectable"]')[0];

        // Only proceed if query success, otherwise return empty string
        if (block) {
            let blockInnerTextContent = block.querySelectorAll(
                'div[data-content-editable-leaf="true"]'
            )[0];
            if (blockContent) return blockInnerTextContent.innerText;
            else return "";
        } else return "";
    };
})();

function getBlockTextContentRiskScore(blockText) {
    // Return a random between 0 to 50
    return Math.random() * 50;
}

// Function to call for each element of the homepage
let runScript = (function () {
    return async function (allNodes) {
        for (i = 0; i < allNodes.length; i++) {
            // Reset score
            let score = 0;
            // Get the current node
            let node = allNodes[i];
            // Get block's text content for analysis
            let blockTextContent = getTextContent(node);
            // Make backend call to identify if content might be generated by a bot
            blockTextRiskScore = getBlockTextContentRiskScore(blockTextContent);
            // Log score of content
            console.log(
                "Paragraph has a risk score eval of: " + blockTextRiskScore
            );

            if (blockTextRiskScore) {
                // Only add the score if it has not already been added
                // totalScore += score;
                // if (!activePopup) counter++;
                // if (counter >= 10) {
                //     activePopup = true;
                //     counter = 0;
                // }
                // addWarning(node, score);
            }
        }
    };
})();

function waitFor(
    varSetter: any,
    sleepTime: any,
    condition: any,
    continuation: any
) {
    let variable = varSetter();
    if (!condition(variable)) {
        setTimeout(
            () => waitFor(varSetter, sleepTime, condition, continuation),
            sleepTime
        );
    } else {
        continuation(variable);
    }
}

waitFor(
    getWrapper,
    2500,
    (wrapper) => wrapper !== undefined,
    function (wrapper) {
        console.log("Preliminary wrapper get succeeded");
        // First pass
        let blocks = wrapper.children;
        console.log("wrapper", wrapper.children);
        runScript(blocks);
        // Observe for changes of wrapper's child nodes
        (() => {
            scanDiv(wrapper, function (el) {
                var addedNodes = [],
                    removedNodes = [];

                // Record down added divs
                el.forEach((record) => {
                    record.addedNodes.length &
                        addedNodes.push(...record.addedNodes);
                });

                // Record down deleted divs
                el.forEach(
                    (record) =>
                        record.removedNodes.length &
                        removedNodes.push(...record.removedNodes)
                );

                // Run the script for added nodes
                runScript(addedNodes);

                console.log("Added:", addedNodes, "Removed:", removedNodes);
            });
        })();
    }
);
